#  Vue 源码目录及构建过程分析

梳理 `Vue` 源码的目录结构，以及 `Vue` 源码构建流程，对 Vue 源码有一个整体了解，有助于后续对源码的阅读


## Vue 源码目录结构

```
|——.github ------------------------------- github 贡献指南，包括代码提交规范、issue规范、PR规范等
|—— benchmarks ---------------------------- 性能测试文件
|—— dist ---------------------------------- rollup 构建输出不同版本 vue 文件
|—— examples ------------------------------ vue 使用的一些 demo
|—— flow ---------------------------------- JS静态类型检查工具 [Flow](https://flowtype.org/) 的类型声明
|—— packages ------------------------------ 独立的 vue 相关 npm 包
|—— scripts ------------------------------- 包含与构建相关的脚本和配置文件
│   ├── alias.js -------------------------- 源码中使用到的模块导入别名
│   ├── build.js -------------------------- 构建打包输出文件路径
│   ├── config.js ------------------------- 项目的构建配置
├── src ----------------------------------- 源码目录
│   ├── compiler -------------------------- 编译器代码，用来将 template 编译为 render 函数
│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成 render 函数的代码
│   │   ├── directives --------------------- v-on, v-bind, v-cloak, v-model 指令
│   │   ├── parser ------------------------ 存放将模板字符串转换成元素 AST 抽象语法树的代码
│   │   ├── create-compiler.js ------------- createCompilerCreator 方法 返回 compile，compileToFunctions
│   │   ├── optimizer.js ------------------ 分析静态树，优化 vdom 渲染
│   ├── core ------------------------------ 存放通用的，平台无关的运行时代码
│   │   ├── components -------------------- 包含抽象出来的通用组件，目前只有keep-alive
│   │   ├── global-api -------------------- 给 Vue 构造函数挂载全局方法(静态方法)或属性的代码(config, set, delete, extend, nextTick……)
│   │   ├── instance ---------------------- Vue构造函数与原型相关代码
│   │   ├── observer ---------------------- 响应式实现，包含数据观测的核心代码
│   │   ├── vdom -------------------------- 虚拟DOM的 creation 和 patching 的代码
│   ├── server ---------------------------- 服务端渲染(server-side rendering)的相关代码
│   ├── platforms ------------------------- 不同平台特有的相关代码
│   │   ├── weex -------------------------- weex 平台支持
│   │   ├── web --------------------------- web平台支持
│   │   │   ├── entry-runtime.js ---------------- 运行时构建的入口
│   │   │   ├── entry-runtime-with-compiler.js -- 运行时+编译器构建版本的入口
│   │   │   ├── entry-compiler.js --------------- vue-template-compiler 包的入口文件
│   │   │   ├── entry-server-renderer.js -------- vue-server-renderer 包的入口文件
│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包
│   ├── shared ---------------------------- 整个代码库通用的代码
|   |    
├── test ---------------------------------- 测试文件
├── types --------------------------------- TypeScript 类声明文件
├── .flowconfig ---------------------------- flow 配置文件
```

### compiler

该目录是编译相关的代码，将 `template` 模板转化成 `render` 函数的代码。

`vue` 提供了 `render` 函数，`render` 函数作用是用来创建 `VNode`，但在平时开发中，绝大多数情况下使用 el 或 template 来创建 HTML，所以需要将它们编译成 render 函数。

编译工作既可以在代码构建时做，也可以在客户端运行时做，但编译十分消耗性能，所以在项目中建议使用 runtime 版本

### core

这部分代码是 vue 的核心代码，可以说是 vue 的灵魂所在，也是我们要重点学习的源码。

core 目录又包含如下子目录。

```
|—— components ---------------------------- 内置组件的代码，即 keep-alive 代码
|—— global-api ---------------------------- 全局 API 代码, 全局属性：config、util; 
全局方法：set、delete、nextTick、observable、options(components, directives, filters, _base)、Vue.use、Vue.mixin、Vue.extend、Vue.component、Vue.directive、Vue.filter
|—— instance ------------------------------- vue 实例化相关代码
│   ├── event.js -------------------------- initEvents, add 添加事件监听, remove 移除事件监听, eventsMixin
│   ├── index.js -------------------------- 定义 Vue 构造函数，添加原型属性和方法；initMixin，stateMixin，eventsMixin，lifecycleMixin，renderMixin
│   ├── init.js ---------------------------- 定义 initMixin
│   ├── inject.js -------------------------- 定义 initInjections
│   ├── lifecycle.js ----------------------- 定义 lifecycleMixin
│   ├── proxy.js --------------------------- 定义 initProxy
│   ├── render.js -------------------------- 定义 renderMixin，initRender
│   ├── state.js --------------------------- 定义 initState，initProps, initData, initComputed, initMethods, initWatch, stateMixin
|—— observer ------------------------------ 数据响应式
│   ├── array.js -------------------------- 重写数组方法 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'
│   ├── dep.js ---------------------------- 依赖收集 Dep 类，方法(addSub, removeSub, depend, notify, pushTarget, popTarget)
│   ├── index.js --------------------------- 构建响应式系统 (Observer, observe, defineReactive, set, del)
│   ├── watch.js --------------------------- 数据监听 Watcher（get, addDep, cleanupDeps, update, run , evaluate, depend, teardown)
|—— vdom ----------------------------------- 虚拟 DOM 和组件创建，patch 更新真实 DOM
│   ├── create-component.js ---------------- 组件钩子函数(init, prepatch, insert, destroy ), createComponent 创建组件
│   ├── create-element.js ------------------ createElement 创建元素 (原生标签 - new Vnode, 组件 -> createComponent)
│   ├── create-functional.component.js ----- 创建函数式组件
│   ├── patch.js --------------------------- createPatchFunction， createElm, createComponent diff算法，跟新真实DOM
│   ├── vnode.js --------------------------- VNode 类

```

添加原型属性和方法

- initMixin：添加 `_init` 方法
- stateMixin：添加 `$data`, `$props`, `$set`, `$delete`, `$watch`
- eventsMixin 添加 `$on`, `$once`, `$off`, `$emit` 方法
- lifecycleMixin 添加 `_update`, `$forceUpdate`, `$destroy` 方法
- renderMixin：添加 `$nextTick`, `_render` 方法

### platforms

`platforms` 下包含两个子目录，`web` 和 `weex`。

分别代表可以打包生成在 web 端使用的 vue 代码和在 native 端使用的 weex 代码。美团开源的开发微信小程序的 mpvue 框架也是在这个目录下进行拓展的。

通过不同平台的入口就可以打包出运行在不同平台的版本的 vue 文件。

### server

该目录下是 SSR 相关的代码。

Vue.js 是构建客户端应用程序的框架。除了可以在浏览器中输出 Vue 组件，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。

### sfc

我们平时开发时，都是写 .vue 文件。sfc 的代码就是提供一个解析器，把.vue 文件代码解析成一个 javascript 对象。

### shared

该目录下定义了一些公用的工具方法，提供给上面的几个目录内代码使用。

## Vue 源码构建

vue 的源码按照功能拆分的十分清晰，每个功能都有单独的目录，那么项目中引用的 vue 文件是怎么编译出来的呢？

首先，我们看一下编译输出的 dist 目录。

```
|—— dist 
│   ├── vue.common.dev.js // common.js 规范未压缩开发版本
│   ├── vue.common.prod.js // common.js 规范压缩生产版本
│   ├── vue.esm.browser.js 
│   ├── vue.esm.browser.min.js 
│   ├── vue.esm.js // ES Module 规范
│   ├── vue.js  // UMD 规范
│   ├── vue.min.js // UMD 规范压缩版本
│   ├── vue.runtime.common.dev.js // runtime only 版本
│   ├── vue.runtime.common.js 
│   ├── vue.runtime.common.prod.js 
│   ├── vue.runtime.esm.js 
│   ├── vue.runtime.js 
│   ├── vue.runtime.min.js
```

可以看到，dist 下有 10 几种不同版本的 vue 文件，他们是根据不同规范（包括 CommonJS 规范，ES Module，UMD）和 是否包含编译器 构建出的不同版本。

vue 源码选择了 rollup 进行构建，rollup 相比于 webpack，更加轻量，编译后的代码更加干净，更适合 javascript 库的构建，除了 vue 以外，像 React，Ember，D3，Three.js 以及其他很多开源库也选择了 Rollup 进行构建。

下面看一下 vue 具体构建过程，首先到 pakage.json 中看下 vue 编译执行的命令。

```shell
    "dev": "rollup -w -c scripts/config.js --source-map --environment TARGET:web-full-dev",
    "dev:cjs": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev",
    "dev:esm": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm",
    "build": "node scripts/build.js"
```

从命令可以看出，构建命令就是执行 scripts 目录下 build.js 文件。

下面是 scripts/build.js 核心代码

```js
// 判断是否存在 dist 目录，不存在就创建 dist
if (!fs.existsSync('dist')) {
  fs.mkdirSync('dist')
}

// 读取构建需要的配置
let builds = require('./config').getAllBuilds()

// 根据构建命令传入的参数过滤配置，过滤后的配置构建出不同 vue 版本文件
// filter builds via command line arg
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // filter out weex builds by default
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}

build(builds)
```

从代码可以看出，首先通过 script/config.js 文件的 getAllBuilds 方法获取配置，然后根据构建命令传入的参数对配置进行过滤，最后根据过滤后的配置执行 build 函数，编译出对应版本的 vue 文件。

看一下 build 方法

```js
function build (builds) {
  let built = 0
  const total = builds.length
  const next = () => {
    buildEntry(builds[built]).then(() => {
      // 递归处理构建输出文件
      built++
      if (built < total) {
        next()
      }
    }).catch(logError)
  }

  next()
}
```

上面可以看到，build 方法递归的调用 `next` 方法，`next` 方法调用 `buildEntry` 打包输出

```js
function buildEntry (config) {
  const output = config.output
  const { file, banner } = output
  const isProd = /(min|prod)\.js$/.test(file) // 生产版本
  return rollup.rollup(config)
    .then(bundle => bundle.generate(output))
    .then(({ output: [{ code }] }) => {
      if (isProd) { // 生产版本开启代码压缩
        const minified = (banner ? banner + '\n' : '') + terser.minify(code, {
          toplevel: true,
          output: {
            ascii_only: true
          },
          compress: {
            pure_funcs: ['makeMap']
          }
        }).code
        return write(file, minified, true)
      } else {
        return write(file, code)
      }
    })
}
```

接下来我们在看一下配置文件 script/config.js 中的 getAllBuilds 是怎么获取具体配置的。

```js
if (process.env.TARGET) {
  module.exports = genConfig(process.env.TARGET)
} else {
  exports.getBuild = genConfig
  exports.getAllBuilds = () => Object.keys(builds).map(genConfig) // 
}
```

可以看出，getAllBuilds 方法首先通过 Object.keys 拿到 builds 对象所有 key 的组成的数组，并通过 map 遍历执行 genConfig 方法。下面我们先看一下 builds 对象。

```js
const aliases = require('./alias')
const resolve = p => {
  const base = p.split('/')[0]
  if (aliases[base]) {
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}

const builds = {
  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify
  'web-runtime-cjs-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.dev.js'),
    format: 'cjs',
    env: 'development',
    banner
  },
  'web-runtime-cjs-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.prod.js'),
    format: 'cjs',
    env: 'production',
    banner
  },
  // Runtime+compiler CommonJS build (CommonJS)
  'web-full-cjs-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.common.dev.js'),
    format: 'cjs',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  'web-full-cjs-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.common.prod.js'),
    format: 'cjs',
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime only ES modules build (for bundlers)
  'web-runtime-esm': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.esm.js'),
    format: 'es',
    banner
  },
  // Runtime+compiler ES modules build (for bundlers)
  'web-full-esm': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.js'),
    format: 'es',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler ES modules build (for direct import in browser)
  'web-full-esm-browser-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.browser.js'),
    format: 'es',
    transpile: false,
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler ES modules build (for direct import in browser)
  'web-full-esm-browser-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.browser.min.js'),
    format: 'es',
    transpile: false,
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
  // runtime-only build (Browser)
  'web-runtime-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.js'),
    format: 'umd',
    env: 'development',
    banner
  },
  // runtime-only production build (Browser)
  'web-runtime-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.min.js'),
    format: 'umd',
    env: 'production',
    banner
  },
  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler production build  (Browser)
  'web-full-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.min.js'),
    format: 'umd',
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
  // Web compiler (CommonJS).
  'web-compiler': {
    entry: resolve('web/entry-compiler.js'),
    dest: resolve('packages/vue-template-compiler/build.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/vue-template-compiler/package.json').dependencies)
  },
  // Web compiler (UMD for in-browser use).
  'web-compiler-browser': {
    entry: resolve('web/entry-compiler.js'),
    dest: resolve('packages/vue-template-compiler/browser.js'),
    format: 'umd',
    env: 'development',
    moduleName: 'VueTemplateCompiler',
    plugins: [node(), cjs()]
  },
  // Web server renderer (CommonJS).
  'web-server-renderer-dev': {
    entry: resolve('web/entry-server-renderer.js'),
    dest: resolve('packages/vue-server-renderer/build.dev.js'),
    format: 'cjs',
    env: 'development',
    external: Object.keys(require('../packages/vue-server-renderer/package.json').dependencies)
  },
  'web-server-renderer-prod': {
    entry: resolve('web/entry-server-renderer.js'),
    dest: resolve('packages/vue-server-renderer/build.prod.js'),
    format: 'cjs',
    env: 'production',
    external: Object.keys(require('../packages/vue-server-renderer/package.json').dependencies)
  },
  'web-server-renderer-basic': {
    entry: resolve('web/entry-server-basic-renderer.js'),
    dest: resolve('packages/vue-server-renderer/basic.js'),
    format: 'umd',
    env: 'development',
    moduleName: 'renderVueComponentToString',
    plugins: [node(), cjs()]
  },
  'web-server-renderer-webpack-server-plugin': {
    entry: resolve('server/webpack-plugin/server.js'),
    dest: resolve('packages/vue-server-renderer/server-plugin.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/vue-server-renderer/package.json').dependencies)
  },
  'web-server-renderer-webpack-client-plugin': {
    entry: resolve('server/webpack-plugin/client.js'),
    dest: resolve('packages/vue-server-renderer/client-plugin.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/vue-server-renderer/package.json').dependencies)
  },
  // Weex runtime factory
  'weex-factory': {
    weex: true,
    entry: resolve('weex/entry-runtime-factory.js'),
    dest: resolve('packages/weex-vue-framework/factory.js'),
    format: 'cjs',
    plugins: [weexFactoryPlugin]
  },
  // Weex runtime framework (CommonJS).
  'weex-framework': {
    weex: true,
    entry: resolve('weex/entry-framework.js'),
    dest: resolve('packages/weex-vue-framework/index.js'),
    format: 'cjs'
  },
  // Weex compiler (CommonJS). Used by Weex's Webpack loader.
  'weex-compiler': {
    weex: true,
    entry: resolve('weex/entry-compiler.js'),
    dest: resolve('packages/weex-template-compiler/build.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/weex-template-compiler/package.json').dependencies)
  }
}
```

可以看出，builds 对象是不同版本 vue 的编译配置

```js
function genConfig (name) {
  const opts = builds[name]
  const config = {
    input: opts.entry, // 打包入口
    external: opts.external, // 第三方依赖或独立 npm 包
    plugins: [
      flow(),
      alias(Object.assign({}, aliases, opts.alias))
    ].concat(opts.plugins || []),
    output: {
      file: opts.dest, // 打包输出文件
      format: opts.format, // 文件规范 umd, commonjs, esm
      banner: opts.banner,
      name: opts.moduleName || 'Vue'
    },
    onwarn: (msg, warn) => {
      if (!/Circular/.test(msg)) {
        warn(msg)
      }
    }
  }

  // built-in vars
  const vars = {
    __WEEX__: !!opts.weex,
    __WEEX_VERSION__: weexVersion,
    __VERSION__: version
  }
  // feature flags
  Object.keys(featureFlags).forEach(key => {
    vars[`process.env.${key}`] = featureFlags[key]
  })
  // build-specific env
  if (opts.env) {
    vars['process.env.NODE_ENV'] = JSON.stringify(opts.env)
  }
  config.plugins.push(replace(vars))

  if (opts.transpile !== false) {
    config.plugins.push(buble())
  }

  Object.defineProperty(config, '_name', {
    enumerable: false,
    value: name
  })

  return config
}
```

`genConfig` 通过 key 拿到 builds 中每个 key 对应的配置对象，然后根据这个对象重新定义一个 config 对象，这个 config 对象的结构才是 rollup 配置真正需要的结构。

看了 builds 对象和 genConfig 方法，我们就知道了 getAllBuilds 的目的，是通过映射把 builds 配置对象转化成 rollup 所需要的配置数据。

到这里，我们就清楚是如何构建出不同版本的 vue 代码了。

## 总结

学习源码时，不建议按照源码的顺序一行一行的阅读。首先要抓住主干，先梳理清楚主要的代码逻辑，再去仔细阅读具体的每行代码。另外按照源码顺序阅读可能很枯燥，很难坚持下来，可以先选择自己感兴趣的部分进行学习，最后再串联起来。