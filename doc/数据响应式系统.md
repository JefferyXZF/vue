# 数据响应式系统

## 初始化响应式

 `vue` 的 **响应式** 是它最重要的特性之一，掌握响应式核心原理，有助于理解 `Vue` 源码优秀的设计思想，那 `vue` 是如果构造自己的响应式系统？

在实例化 `vue` 执行` _init` 方法的时候，执行 `initState(vm)` 方法，它是构造响应式系统的核心，定义在 `src/core/instance/state.js` 中。

```js
function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  // 初始化 props
  if (opts.props) { initProps(vm, opts.props); }
  // 初始化 methods
  if (opts.methods) { initMethods(vm, opts.methods); }
  // 初始化 data
  if (opts.data) {
    initData(vm);
  } else {
    // 如果没有定义data，则创建一个空对象，并设置为响应式
    observe(vm._data = {}, true /* asRootData */);
  }
  // 初始化 computed
  if (opts.computed) { initComputed(vm, opts.computed); }
  // 初始化 watch
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}
```

`initState` 方法主要是对 `props`、`methods`、`data`、`computed` 和 `wathcer` 等属性做了初始化操作

## initProps

在初始化 `props` 之前，vue 已经做了两件事情，一是在选项合并的时候规范 `props`  ，二是接收父组件传递的值放在`propsData` 中

```js
function initProps (vm: Component, propsOptions: Object) {
  // 接收父组件的值
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  // root instance props should be converted
  // 有父组件
  if (!isRoot) {
    // props 嵌套对象不做响应式处理
    toggleObserving(false)
  }
  // 遍历 props
  for (const key in propsOptions) {
    keys.push(key)
    // 校验 props 属性 ，并取得 props 属性值
    const value = validateProp(key, propsOptions, propsData, vm)
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      const hyphenatedKey = hyphenate(key)
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          `"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      // 如果重写 props 报错
      defineReactive(props, key, value, () => {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: "${key}"`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value)
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
  toggleObserving(true)
}

```



上面的逻辑是如果有父组件，执行`toggleObserving(false)` ，`props` 的嵌套对象不会进行响应式处理，因为父组件传递对象的时候已经实现了响应式

遍历定义的 `props` 配置，执行 `validateProp` 方法检验 `props` 属性并取得它的值，调用 `defineReactive` 方法把每个 `prop` 对应的值变成响应式，然后通过 `proxy` 把 `vm._props.xxx` 的访问代理到 `vm.xxx` 上。



### validateProp 校验



- 首先校验 `props`  Boolean 类型的数据
- 如果 `propsData` 值为空，说明父组件没有传值，从 `default` 取得默认值，默认值实现响应式，并且默认值嵌套对象也做响应式
- `assertProp` 进行 `required`  `validator` 校验

```js
function validateProp (
  key: string,
  propOptions: Object,
  propsData: Object,
  vm?: Component
): any {
  const prop = propOptions[key]
  const absent = !hasOwn(propsData, key)
  // 从父组件传递的 prop 数据
  let value = propsData[key]
  // boolean casting
  // 处理 Boolean 类型的数据
  // 判断 prop 的定义是否是 Boolean 类型的。
  const booleanIndex = getTypeIndex(Boolean, prop.type)
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      const stringIndex = getTypeIndex(String, prop.type)
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true
      }
    }
  }
  // check default value
  // 处理默认数据
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key)
    // since the default value is a fresh copy,
    // make sure to observe it.
    const prevShouldObserve = shouldObserve
    toggleObserving(true)
    observe(value)
    toggleObserving(prevShouldObserve)
  }
  if (
    process.env.NODE_ENV !== 'production' &&
    // skip validation for weex recycle-list child component props
    !(__WEEX__ && isObject(value) && ('@binding' in value))
  ) {
    // assertProp 函数的目的是断言这个 prop 是否合法
    // 先判断如果 prop 定义了 required 属性但父组件没有传递这个 prop 数据的话会报一个警告。

    // 接着判断如果 value 为空且 prop 没有定义 required 属性则直接返回。

    // 然后再去对 prop 的类型做校验，先是拿到 prop 中定义的类型 type，并尝试把它转成一个类型数组，然后依次遍历这个数组，执行 assertType(value, type[i]) 去获取断言的结果，直到遍历完成或者是 valid 为 true 的时候跳出循环。
    assertProp(prop, key, value, vm, absent)
  }
  return value
}
```



### propsData

在执行 `render` 函数生成 `vnode`的过程，如果遇到 `components` 子组件占位符节点，会创建子 `vnode` 调用`createComponent`,。对于`props` 的处理，`extractPropsFromVNodeData` 会对 `attrs` 属性进行规范校验后，最后会把校验后的结果以 `propsData` 属性的形式传入 `vnode` 构造器中。总结来说，`props` 传递给占位符组件的写法，会以 `propsData` 的形式作为子组件 `vnode` 的属性存在

```js
// 创建子组件过程
function createComponent() {
  // props校验
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);
  ···
  // 创建子组件vnode
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );
}
```



`data` 参数是 `createElement(tag, data, children)` 的 data 值，标签或组件绑定的属性值经过编译后存储在 `data.attrs` 上

```js
function extractPropsFromVNodeData (data,Ctor,tag) {
  // Ctor为子类构造器
  ···
  var res = {};
  // 子组件props选项
  var propOptions = Ctor.options.props;
  // data.attrs针对编译生成的render函数，data.props针对用户自定义的render函数
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      // aB 形式转成 a-b
      var altKey = hyphenate(key);
      {
          var keyInLowerCase = key.toLowerCase();
          if (
            key !== keyInLowerCase &&
            attrs && hasOwn(attrs, keyInLowerCase)
          ) {
            // 警告
          }
        }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false)
    }
  }
}

function checkProp (
  res: Object,
  hash: ?Object,
  key: string,
  altKey: string,
  preserve: boolean
): boolean {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key]
      if (!preserve) {
        delete hash[key]
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey]
      if (!preserve) {
        delete hash[altKey]
      }
      return true
    }
  }
  return false
}
```



上面实现逻辑，遍历 `props` ，从父组件 data 的 `props`  和 `attrs` 取值，如果有值，则删除父组件 `attrs` 上的属性，这就是为什么通过 `v-bind="$attrs"` 可以继承父组件的属性



## initMethods

`initMethod`方法和介绍的响应式没有任何的关系，他的实现也相对简单，主要是保证 `methods`  方法定义必须是函数，且命名不能和`props` 以及 `vm` 实例属性方法重复，最终会将定义的方法都挂载到根实例上。



```js
function initMethods (vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        // method必须为函数形式
        if (typeof methods[key] !== 'function') {
          warn(
            "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
            "Did you reference the function correctly?",
            vm
          );
        }
        // methods方法名不能和props重复
        if (props && hasOwn(props, key)) {
          warn(
            ("Method \"" + key + "\" has already been defined as a prop."),
            vm
          );
        }
        //  不能以_ or $.这些Vue保留标志开头
        if ((key in vm) && isReserved(key)) {
          warn(
            "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
            "Avoid defining component methods that start with _ or $."
          );
        }
      }
      // 直接挂载到实例的属性上,可以通过vm[method]访问。
      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
  }
```



## initData

`data` 在初始化选项合并时会生成一个函数，只有在执行函数时才会返回真正的数据，所以 `initData` 方法会先执行拿到组件的 `data` 数据，并且会对对象每个属性的命名进行校验，保证不能和 `props，methods` 重复。最后的核心方法是 `observe`, `observe` 方法是将**数据对象标记为响应式对象**，并对对象的每个属性进行响应式处理。与此同时，和`props`的代理处理方式一样，`proxy` 会对 `data` 做一层代理，直接通过`vm.XXX`可以代理访问到`vm._data`上挂载的对象属性（如果data 属性使用 `.` `_` 符号开头不能实现代理）。

```js
function initData(vm) {
  var data = vm.$options.data;
  // 根实例时，data是一个对象，子组件的data是一个函数，其中getData会调用函数返回data对象
  data = vm._data = typeof data === 'function'? getData(data, vm): data || {};
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      // 命名不能和方法重复
      if (methods && hasOwn(methods, key)) {
        warn(("Method \"" + key + "\" has already been defined as a data property."),vm);
      }
    }
    // 命名不能和props重复
    if (props && hasOwn(props, key)) {
      warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.",vm);
    } else if (!isReserved(key)) {
      // 数据代理，用户可直接通过vm实例返回data数据
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}
```



### data 依赖收集

`data` 在初始化阶段会实例化一个 `Observer`类，这个类的定义如下(忽略数组类型的`data`):

```js
// initData 
function initData(data) {
  ···
  observe(data, true)
}
// observe
function observe(value, asRootData) {
  ···
  ob = new Observer(value);
  return ob
}
// 观察者类，对象只要设置成拥有观察属性，则对象下的所有属性都会重写getter和setter方法，而getter，setting方法会进行依赖的收集和派发更新
var Observer = function Observer (value) {
    ···
    // 将__ob__属性设置成不可枚举属性。外部无法通过遍历获取。
    def(value, '__ob__', this);
    // 数组处理
    if (Array.isArray(value)) {
        ···
    } else {
      // 对象处理
      this.walk(value);
    }
  };
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable, // 是否可枚举
    writable: true,
    configurable: true
  });
}
```

`Observer`会为`data`添加一个`__ob__`属性， `__ob__`属性是作为响应式对象的标志，同时`def`方法确保了该属性是不可枚举属性，即外界无法通过遍历获取该属性值。除了标志响应式对象外，`Observer`类还调用了原型上的`walk`方法，遍历对象上每个属性进行`getter,setter`的改写。



```js
Observer.prototype.walk = function walk (obj) {
    // 获取对象所有属性，遍历调用defineReactive###1进行改写
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        defineReactive(obj, keys[i]);
    }
};
```

`defineReactive `是响应式构建的核心，它会先**实例化一个`Dep`类，即为每个数据都创建一个依赖的管理**，之后利用 `Object.defineProperty` 重写 `getter,setter` 方法。这里我们只分析依赖收集的代码。



```js
function defineReactive (obj,key,val,customSetter,shallow) {
    // 每个数据实例化一个Dep类，创建一个依赖的管理
    var dep = new Dep();
    var property = Object.getOwnPropertyDescriptor(obj, key);
    // 属性必须满足可配置
    if (property && property.configurable === false) {
      return
    }
    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    // 这一部分的逻辑是针对深层次的对象，如果对象的属性是一个对象，则会递归调用实例化Observe类，让其属性值也转换为响应式对象
    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,s
      get: function reactiveGetter () {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          // 为当前watcher添加dep数据
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value
      },
      set: function reactiveSetter (newVal) {}
    });
  }
```

根据之前介绍，实例挂载前会创建一个渲染 `watcher`

```js
new Watcher(vm, updateComponent, noop, {
  before: function before () {
    if (vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'beforeUpdate');
    }
  }
}, true /* isRenderWatcher */);
```

与此同时，`updateComponent`的逻辑会执行实例的挂载，在这个过程中，模板会被优先解析为 `render` 函数，而 `render` 函数转换成 `vnode` 时，会访问到定义的 `data` 数据，这个时候会触发 `gettter` 进行依赖收集。而此时数据收集的依赖就是这个渲染`watcher`本身。



代码中依赖收集阶段会做下面几件事：

- **为当前的`watcher`(该场景下是渲染`watcher`)添加拥有的数据**。

- **为当前的数据收集需要监听的依赖**

如何理解这两点？我们先看代码中的实现。`getter`阶段会执行`dep.depend()`,这是`Dep`这个类定义在原型上的方法。



```js
dep.depend();
Dep.prototype.depend = function depend () {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };
```



`Dep.target`为当前执行的`watcher`,在渲染阶段，`Dep.target`为组件挂载时实例化的渲染`watcher`,因此`depend`方法又会调用当前`watcher`的`addDep`方法为`watcher`添加依赖的数据。



```js
Watcher.prototype.addDep = function addDep (dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      // newDepIds和newDeps记录watcher拥有的数据
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      // 避免重复添加同一个data收集器
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };
```



其中`newDepIds`是具有唯一成员是`Set`数据结构，`newDeps`是数组，他们用来记录当前`watcher`所拥有的数据，这一过程会进行逻辑判断，避免同一数据添加多次。

`addSub`为每个数据依赖收集器添加需要被监听的`watcher`。



```js
Dep.prototype.addSub = function addSub (sub) {
  //将当前watcher添加到数据依赖收集器中
    this.subs.push(sub);
};
```



## data 派发更新

在数据发生改变时，会执行定义好的`setter`方法，我们先看源码。



```js
Object.defineProperty(obj,key, {
  ···
  set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      // 新值和旧值相等时，跳出操作
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      ···
      // 新值为对象时，会为新对象进行依赖收集过程
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
})
```



派发更新阶段会做以下几件事：

- **判断数据更改前后是否一致，如果数据相等则不进行任何派发更新操作**。
- **新值为对象时，会对该值的属性进行依赖收集过程**。
- **通知该数据收集的`watcher`依赖,遍历每个`watcher`进行数据更新**,这个阶段是调用该数据依赖收集器的`dep.notify`方法进行更新的派发。



```js
Dep.prototype.notify = function notify () {
  var subs = this.subs.slice();
  if (!config.async) {
    // 根据依赖的id进行排序
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    // 遍历每个依赖，进行更新数据操作。
    subs[i].update();
  }
};
```



**更新时会将每个`watcher`推到队列中，等待下一个`tick`到来时取出每个`watcher`进行`run`操作**



```js
Watcher.prototype.update = function update () {
  ···
  queueWatcher(this);
};
```



`queueWatcher`方法的调用，会将数据所收集的依赖依次推到`queue`数组中,数组会在下一个事件循环`'tick'`中根据缓冲结果进行视图更新。而在执行视图更新过程中，难免会因为数据的改变而在渲染模板上添加新的依赖，这样又会执行`queueWatcher`的过程。所以需要有一个标志位来记录是否处于异步更新过程的队列中。这个标志位为`flushing`,当处于异步更新过程时，新增的`watcher`会插入到`queue`中。



```js
function queueWatcher (watcher) {
  var id = watcher.id;
  // 保证同一个watcher只执行一次
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    ···
    nextTick(flushSchedulerQueue);
  }
}
```



当下一个`tick`到来时，会执行`flushSchedulerQueue`方法，它会拿到收集的`queue`数组(这是一个`watcher`的集合),并对数组依赖进行排序。为什么进行排序呢？源码中解释了三点：



>- 组件创建是先父后子，所以组件的更新也是先父后子，因此需要保证父的渲染`watcher`优先于子的渲染`watcher`更新。
>
>- **用户自定义的`watcher`,称为`user watcher`。 `user watcher`和`render watcher`执行也有先后，由于`user watchers`比`render watcher`要先创建，所以`user watcher`要优先执行**。
>- 如果一个组件在父组件的 `watcher` 执行阶段被销毁，那么它对应的 `watcher` 执行都可以被跳过。



```js
function flushSchedulerQueue () {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;
    // 对queue的watcher进行排序
    queue.sort(function (a, b) { return a.id - b.id; });
    // 循环执行queue.length，为了确保由于渲染时添加新的依赖导致queue的长度不断改变。
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      // 如果watcher定义了before的配置，则优先执行before方法
      if (watcher.before) {
        watcher.before();
      }
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // in dev build, check and stop circular updates.
      if (has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn(
            'You may have an infinite update loop ' + (
              watcher.user
                ? ("in watcher with expression \"" + (watcher.expression) + "\"")
                : "in a component render function."
            ),
            watcher.vm
          );
          break
        }
      }
    }
    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();
    // 重置恢复状态，清空队列
    resetSchedulerState();
    // 视图改变后，调用其他钩子
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);
    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }
```



`flushSchedulerQueue`阶段，重要的过程可以总结为四点：

> - 对`queue`中的`watcher`进行排序，原因上面已经总结。
> - 遍历`watcher`,如果当前`watcher`有`before`配置，则执行`before`方法，对应前面的渲染`watcher`:在渲染`watcher`实例化时，我们传递了`before`函数，即在下个`tick`更新视图前，会调用`beforeUpdate`生命周期钩子。
> - 执行`watcher.run`进行修改的操作。
> - 重置恢复状态，这个阶段会将一些流程控制的状态变量恢复为初始值，并清空记录`watcher`的队列。

```js
new Watcher(vm, updateComponent, noop, {
  before: function before () {
    if (vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'beforeUpdate');
    }
  }
}, true /* isRenderWatcher */);
```

重点看看`watcher.run()`的操作。



```js
Watcher.prototype.run = function run () {
    if (this.active) {
      var value = this.get();
      if ( value !== this.value || isObject(value) || this.deep ) {
        // 设置新值
        var oldValue = this.value;
        this.value = value;
        // 针对user watcher，暂时不分析
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };
```



首先会执行`watcher.prototype.get`的方法，得到数据变化后的当前值，之后会对新值做判断，如果判断满足条件，则执行`cb`,`cb`为实例化`watcher`时传入的回调。

在分析`get`方法前，回头看看`watcher`构造函数的几个属性定义



```js
var watcher = function Watcher(
  vm, // 组件实例
  expOrFn, // 执行函数
  cb, // 回调
  options, // 配置
  isRenderWatcher // 是否为渲染watcher
) {
  this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        warn(
          "Failed watching path: \"" + expOrFn + "\" " +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        );
      }
    }
    // lazy为计算属性标志，当watcher为计算watcher时，不会理解执行get方法进行求值
    this.value = this.lazy
      ? undefined
      : this.get();
}
```



方法`get`的定义如下：

```js
Watcher.prototype.get = function get () {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
     ···
    } finally {
      ···
      // 把Dep.target恢复到上一个状态，依赖收集过程完成
      popTarget();
      this.cleanupDeps();
    }
    return value
  };

```



`get`方法会执行`this.getter`进行求值，在当前渲染`watcher`的条件下,`getter`会执行视图更新的操作。这一阶段会**重新渲染页面组件**

```js
new Watcher(vm, updateComponent, noop, { before: () => {} }, true);
updateComponent = function () {
  vm._update(vm._render(), hydrating);
};
```



执行完`getter`方法后，最后一步会进行依赖的清除，也就是`cleanupDeps`的过程。

> 关于依赖清除的作用，我们列举一个场景： 我们经常会使用`v-if`来进行模板的切换，切换过程中会执行不同的模板渲染，如果A模板监听a数据，B模板监听b数据，当渲染模板B时，如果不进行旧依赖的清除，在B模板的场景下，a数据的变化同样会引起依赖的重新渲染更新，这会造成性能的浪费。因此旧依赖的清除在优化阶段是有必要。



```js
// 依赖清除的过程
  Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };
```



总结成依赖派发更新的最后两个点

- **执行`run`操作会执行`getter`方法,也就是重新计算新值，针对渲染`watcher`而言，会重新执行`updateComponent`进行视图更新**
- **重新计算`getter`后，会进行依赖的清除**



## initComputed

`initComputed` 是 `computed` 数据的初始化, 源码实现逻辑：

- `computed` 可以是对象，也可以是函数，但是对象必须有 `getter` 方法, 如果 `computed` 中的属性值是对象时需要进行验证。

- 针对 `computed` 的每个属性，要创建一个监听的依赖，也就是实例化一个 `watcher`, `watcher`的定义，可以暂时理解为数据使用的依赖本身，一个 `watcher` 实例代表了一个需要被监听的数据依赖。

- `initComputed`  将每个 `computed` 属性设置成响应式的数据，同样的，也会对`computed`的命名做检测，防止与 `props,data` 冲突。



```js
// computed watcher的标志，lazy属性为true
var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  ···
  for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      // computed属性为对象时，要保证有getter方法
      if (getter == null) {
        warn(("Getter is missing for computed property \"" + key + "\"."),vm);
      }
      if (!isSSR) {
        // 创建computed watcher
        watchers[key] = new Watcher(vm,getter || noop,noop,computedWatcherOptions);
      }
      if (!(key in vm)) {
        // 设置为响应式数据
        defineComputed(vm, key, userDef);
      } else {
        // 不能和props，data命名冲突
        if (key in vm.$data) {
          warn(("The computed property \"" + key + "\" is already defined in data."), vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
        }
      }
    }
}
```

`

`defineComputed`的逻辑和分析`data`的逻辑相似，最终调用 `Object.defineProperty` 进行数据拦截。具体的定义如下：

```js
function defineComputed (target,key,userDef) {
  // 非服务端渲染会对getter进行缓存
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    // 
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}
```



在非服务端渲染的情形，计算属性的计算结果会被缓存，缓存的意义在于，**只有在相关响应式数据发生变化时，`computed`才会重新求值，其余情况多次访问计算属性的值都会返回之前计算的结果，这就是缓存的优化**

`computed`属性有两种写法，一种是函数，另一种是对象，其中对象的写法需要提供 `getter` 和 `setter` 方法。

当访问到 `computed` 属性时，会触发 `getter` 方法进行依赖收集，看看`createComputedGetter`的实现。



```js
function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      // dirty是标志是否已经执行过计算结果，如果执行过则不会执行watcher.evaluate重复计算，这也是缓存的原理
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}
```



`createComputedGetter`返回的函数在执行过程中会先拿到属性的`computed watcher`, `dirty` 标志是否已经执行过计算结果，如果执行过则不会执行`watcher.evaluate`重复计算，这也是缓存的原理。



```js
Watcher.prototype.evaluate = function evaluate () {
    // 对于计算属性而言 evaluate的作用是执行计算回调
    this.value = this.get();
    this.dirty = false;
  };
```



### computed 依赖收集

和 `data` 分析一样，当访问 `computed` 属性会触发 `computedGetter` 方法，`watcher.dirty` 为 `true` 执行 `watcher.evaluate()` 从而调用 `get` 方法，如果 computed 计算访问 `data` 数据的属性值，会触发 `data` 数据的`getter`方法进行依赖收集，根据前面分析，`data`的`Dep`收集器会将当前 `watcher` 作为依赖进行收集，而这个`watcher`就是 `computed watcher`，并且会为当前的 `watcher` 添加访问的数据`Dep`



回到计算执行函数的`this.get()`方法，`getter`执行完成后同样会进行依赖的清除，原理和目的参考`data`阶段的分析。`get`执行完毕后会进入`watcher.depend`进行依赖的收集。收集过程和`data`一致,将当前的`computed watcher`作为依赖收集到数据的依赖收集器`Dep`中。

这就是`computed`依赖收集的完整过程，对比`data`的依赖收集，`computed`会对运算的结果进行缓存，避免重复执行运算过程。



### computed 派发更新

- 当计算属性依赖的数据发生更新时，由于数据的`Dep`收集过`computed watch`这个依赖，所以会调用`dep`的`notify`方法，对依赖进行状态更新。
- 此时`computed watcher`和之前介绍的`watcher`不同，它不会立刻执行依赖的更新操作，而是通过一个`dirty`进行标记。我们再回头看`依赖更新`的代码。



```js
Dep.prototype.notify = function() {
  ···
   for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
}
Watcher.prototype.update = function update () {
  // 计算属性分支  
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
```



由于`lazy`属性的存在，`update`过程不会执行状态更新的操作，只会将`dirty`标记为`true`。

- 由于 `data` 数据拥有渲染 `watcher` 这个依赖，所以同时会执行`updateComponent`进行视图重新渲染,而`render`过程中会访问到计算属性,此时由于`this.dirty`值为`true`,又会对计算属性重新求值。



## initWatch



初始化 `watch` ，遍历 `watch`, 如果 watch 属性值是一个数组，则递归处理。`initWatch`的核心是`createWatcher`

```js
function initWatch (vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key]
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}

function createWatcher (vm,expOrFn,handler,options) {
    // 针对watch是对象的形式，此时回调回选项中的handler
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options)
  }
```



### watch 依赖收集

无论是选项的形式，还是`api`的形式，最终都会调用实例的`$watch`方法，其中`expOrFn`是监听的字符串，`handler`是监听的回调函数，`options`是相关配置。我们重点看看`$watch`的实现



```js
Vue.prototype.$watch = function (expOrFn,cb,options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    // 当watch有immediate选项时，立即执行cb方法，即不需要等待属性变化，立刻执行回调。
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}
```



`$watch`的核心是创建一个`user watcher`,`options.user`是当前用户定义`watcher`的标志。如果有`immediate`属性，则立即执行回调函数。而实例化`watcher`时会执行一次`getter`求值，这时，`user watcher`会作为依赖被数据所收集。这个过程可以参考`data`的分析。



```js
var Watcher = function Watcher() {
  ···
  if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
  this.value = this.lazy
      ? undefined
      : this.get();
}

// 解析字符串
function parsePath (path: string): any {
  if (bailRE.test(path)) {
    return
  }
  const segments = path.split('.')
  return function (obj) {
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}

Watcher.prototype.get = function get() {
  ···
  try {
    // getter回调函数，触发依赖收集
    value = this.getter.call(vm, vm);
  } 
}
```



### watch 派发更新

`watch` 派发更新，当数据发生改变时，`setter`拦截对依赖进行更新，而此前`user watcher`已经被当成依赖收集了。这个时候依赖的更新就是回调函数的执行。



## 响应式 Watch、Dep、Observer 相关概念



