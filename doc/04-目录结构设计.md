#  Vue 源码目录及构建过程分析

梳理 Vue 源码的目录结构，以及 Vue 代码构建流程，对 Vue 源码有一个整体了解，有助于后续对源码的阅读


## Vue 源码目录结构

```
|——.github ------------------------------- github 贡献指南，包括代码提交规范、issue规范、PR规范等
|—— benchmarks ---------------------------- 性能测试文件
|—— dist ---------------------------------- rollup 构建输出不同版本vue文件
|—— examples ------------------------------ vue 使用的一些 demo
|—— flow ---------------------------------- JS静态类型检查工具 [Flow](https://flowtype.org/) 的类型声明
|—— packages ------------------------------ 独立的vue相关npm包
|—— scripts ------------------------------- 包含与构建相关的脚本和配置文件
│   ├── alias.js -------------------------- 源码中使用到的模块导入别名
│   ├── config.js ------------------------- 项目的构建配置
├── src ----------------------------------- 源码目录
│   ├── compiler -------------------------- 编译器代码，用来将 template 编译为 render 函数
│   │   ├── parser ------------------------ 存放将模板字符串转换成元素 AST 抽象语法树的代码
│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成 render 函数的代码
│   │   ├── optimizer.js ------------------ 分析静态树，优化 vdom 渲染
│   ├── core ------------------------------ 存放通用的，平台无关的运行时代码
│   │   ├── components -------------------- 包含抽象出来的通用组件，目前只有keep-alive
│   │   ├── global-api -------------------- 给 Vue 构造函数挂载全局方法(静态方法)或属性的代码
│   │   ├── instance ---------------------- Vue构造函数与原型相关代码
│   │   ├── observer ---------------------- 响应式实现，包含数据观测的核心代码
│   │   ├── vdom -------------------------- 虚拟DOM的 creation 和 patching 的代码
│   ├── server ---------------------------- 服务端渲染(server-side rendering)的相关代码
│   ├── platforms ------------------------- 不同平台特有的相关代码
│   │   ├── weex -------------------------- weex 平台支持
│   │   ├── web --------------------------- web平台支持
│   │   │   ├── entry-runtime.js ---------------- 运行时构建的入口
│   │   │   ├── entry-runtime-with-compiler.js -- 运行时+编译器构建版本的入口
│   │   │   ├── entry-compiler.js --------------- vue-template-compiler 包的入口文件
│   │   │   ├── entry-server-renderer.js -------- vue-server-renderer 包的入口文件
│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包
│   ├── shared ---------------------------- 整个代码库通用的代码
|   |    
├── test ---------------------------------- 测试文件
├── types ---------------------------------- TypeScript 类声明文件
├── .flowconfig ----------------------------- flow 配置文件
```

### compiler

该目录是编译相关的代码，即将 template 模板转化成 render 函数的代码。

vue 提供了 render 函数，render 函数作用是用来创建 VNode，但在平时开发中，绝大多数情况下使用 el 或 template 来创建 HTML，所以需要将它们编译成 render 函数。

编译工作既可以在代码构建时做，也可以在客户端运行时做，但编译十分消耗性能，所以在项目中建议使用 runtime 版本

### core

这部分代码是 vue 的核心代码，可以说是 vue 的灵魂所在，也是我们要重点学习的源码。

core 目录又包含如下子目录。

components – 内置组件的代码，即 keep-alive 代码
global-api – 全局 API 代码，mixin，extend 等 api 在这里实现
instance – vue 实例化相关代码，包括初始化，事件，生命周期，渲染等部分的代码
observer – 响应式数据相关代码
util – 工具方法
vdom – 虚拟 dom 的代码。

### platforms

platforms 下包含两个子目录，web 和 weex。

分别代表可以打包生成在 web 端使用的 vue 代码和在 native 端使用的 weex 代码。美团开源的开发微信小程序的 mpvue 框架也是在这个目录下进行拓展的。

通过不同平台的入口就可以打包出运行在不同平台的版本的 vue 文件。

### server

该目录下是 SSR 相关的代码。

Vue.js 是构建客户端应用程序的框架。除了可以在浏览器中输出 Vue 组件，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。

### sfc

我们平时开发时，都是写 .vue 文件。sfc 的代码就是提供一个解析器，把.vue 文件代码解析成一个 javascript 对象。

### shared

该目录下定义了一些公用的工具方法，提供给上面的几个目录内代码使用。

## 源码编译

vue 的源码按照功能拆分的十分清晰，每个功能都有单独的目录，那么项目中引用的 vue 文件是怎么编译出来的呢？

首先，我们看一下编译输出的 dist 目录。

```
|—— dist 
│   ├── vue.common.dev.js // common.js 规范未压缩版本
│   ├── vue.common.prod.js // common.js 规范压缩生产版本
│   ├── vue.esm.browser.js 
│   ├── vue.esm.browser.min.js 
│   ├── vue.esm.js // ES Module 规范
│   ├── vue.js  // UMD 规范
│   ├── vue.min.js // UMD 规范压缩版本
│   ├── vue.runtime.common.dev.js // runtime only 版本
│   ├── vue.runtime.common.js 
│   ├── vue.runtime.common.prod.js 
│   ├── vue.runtime.esm.js 
│   ├── vue.runtime.js 
│   ├── vue.runtime.min.js
```

可以看到，dist 下有 10 几种不同版本的 vue 文件，他们是根据不同规范（包括 CommonJS 规范，ES Module，UMD）和 是否包含编译器 构建出的不同版本。

vue 源码选择了 rollup 进行构建，rollup 相比于 webpack，更加轻量，编译后的代码更加干净，更适合 javascript 库的构建，除了 vue 以外，像 React，Ember，D3，Three.js 以及其他很多开源库也选择了 Rollup 进行构建。

下面看一下 vue 具体构建过程，首先到 pakage.json 中看下 vue 编译执行的命令。

```shell
    "dev": "rollup -w -c scripts/config.js --source-map --environment TARGET:web-full-dev",
    "dev:cjs": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-cjs-dev",
    "dev:esm": "rollup -w -c scripts/config.js --environment TARGET:web-runtime-esm",
    "build": "node scripts/build.js"
```

从命令可以看出，构建命令就是执行 scripts 目录下 build.js 文件。

下面是 scripts/build.js 核心代码

```js
// 判断是否存在 dist 目录，不存在就创建 dist
if (!fs.existsSync('dist')) {
  fs.mkdirSync('dist')
}

// 读取构建需要的配置
let builds = require('./config').getAllBuilds()

// 根据构建命令传入的参数过滤配置，过滤后的配置构建出不同 vue 版本文件
// filter builds via command line arg
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // filter out weex builds by default
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}

build(builds)
```

从代码可以看出，首先通过 script/config.js 文件的 getAllBuilds 方法获取配置，然后根据构建命令传入的参数对配置进行过滤，最后根据过滤后的配置执行 build 函数，编译出对应版本的 vue 文件。

接下来我们在看一下配置文件 script/config.js 中的 getAllBuilds 是怎么获取具体配置的。

```js
if (process.env.TARGET) {
  module.exports = genConfig(process.env.TARGET)
} else {
  exports.getBuild = genConfig
  exports.getAllBuilds = () => Object.keys(builds).map(genConfig) // 
}
```

可以看出，getAllBuilds 方法首先通过 Object.keys 拿到 builds 对象所有 key 的组成的数组，并通过 map 遍历执行 genConfig 方法。下面我们先看一下 builds 对象。

```js
const aliases = require('./alias')
const resolve = p => {
  const base = p.split('/')[0]
  if (aliases[base]) {
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}

const builds = {
  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify
  'web-runtime-cjs-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.dev.js'),
    format: 'cjs',
    env: 'development',
    banner
  },
  'web-runtime-cjs-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.prod.js'),
    format: 'cjs',
    env: 'production',
    banner
  },
  // Runtime+compiler CommonJS build (CommonJS)
  'web-full-cjs-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.common.dev.js'),
    format: 'cjs',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  'web-full-cjs-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.common.prod.js'),
    format: 'cjs',
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime only ES modules build (for bundlers)
  'web-runtime-esm': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.esm.js'),
    format: 'es',
    banner
  },
  // Runtime+compiler ES modules build (for bundlers)
  'web-full-esm': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.js'),
    format: 'es',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler ES modules build (for direct import in browser)
  'web-full-esm-browser-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.browser.js'),
    format: 'es',
    transpile: false,
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler ES modules build (for direct import in browser)
  'web-full-esm-browser-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.browser.min.js'),
    format: 'es',
    transpile: false,
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
  // runtime-only build (Browser)
  'web-runtime-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.js'),
    format: 'umd',
    env: 'development',
    banner
  },
  // runtime-only production build (Browser)
  'web-runtime-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.min.js'),
    format: 'umd',
    env: 'production',
    banner
  },
  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler production build  (Browser)
  'web-full-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.min.js'),
    format: 'umd',
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
  // Web compiler (CommonJS).
  'web-compiler': {
    entry: resolve('web/entry-compiler.js'),
    dest: resolve('packages/vue-template-compiler/build.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/vue-template-compiler/package.json').dependencies)
  },
  // Web compiler (UMD for in-browser use).
  'web-compiler-browser': {
    entry: resolve('web/entry-compiler.js'),
    dest: resolve('packages/vue-template-compiler/browser.js'),
    format: 'umd',
    env: 'development',
    moduleName: 'VueTemplateCompiler',
    plugins: [node(), cjs()]
  },
  // Web server renderer (CommonJS).
  'web-server-renderer-dev': {
    entry: resolve('web/entry-server-renderer.js'),
    dest: resolve('packages/vue-server-renderer/build.dev.js'),
    format: 'cjs',
    env: 'development',
    external: Object.keys(require('../packages/vue-server-renderer/package.json').dependencies)
  },
  'web-server-renderer-prod': {
    entry: resolve('web/entry-server-renderer.js'),
    dest: resolve('packages/vue-server-renderer/build.prod.js'),
    format: 'cjs',
    env: 'production',
    external: Object.keys(require('../packages/vue-server-renderer/package.json').dependencies)
  },
  'web-server-renderer-basic': {
    entry: resolve('web/entry-server-basic-renderer.js'),
    dest: resolve('packages/vue-server-renderer/basic.js'),
    format: 'umd',
    env: 'development',
    moduleName: 'renderVueComponentToString',
    plugins: [node(), cjs()]
  },
  'web-server-renderer-webpack-server-plugin': {
    entry: resolve('server/webpack-plugin/server.js'),
    dest: resolve('packages/vue-server-renderer/server-plugin.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/vue-server-renderer/package.json').dependencies)
  },
  'web-server-renderer-webpack-client-plugin': {
    entry: resolve('server/webpack-plugin/client.js'),
    dest: resolve('packages/vue-server-renderer/client-plugin.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/vue-server-renderer/package.json').dependencies)
  },
  // Weex runtime factory
  'weex-factory': {
    weex: true,
    entry: resolve('weex/entry-runtime-factory.js'),
    dest: resolve('packages/weex-vue-framework/factory.js'),
    format: 'cjs',
    plugins: [weexFactoryPlugin]
  },
  // Weex runtime framework (CommonJS).
  'weex-framework': {
    weex: true,
    entry: resolve('weex/entry-framework.js'),
    dest: resolve('packages/weex-vue-framework/index.js'),
    format: 'cjs'
  },
  // Weex compiler (CommonJS). Used by Weex's Webpack loader.
  'weex-compiler': {
    weex: true,
    entry: resolve('weex/entry-compiler.js'),
    dest: resolve('packages/weex-template-compiler/build.js'),
    format: 'cjs',
    external: Object.keys(require('../packages/weex-template-compiler/package.json').dependencies)
  }
}
```

可以看出，builds 对象是不同版本 vue 的编译配置

```js
function genConfig (name) {
  const opts = builds[name]
  const config = {
    input: opts.entry,
    external: opts.external,
    plugins: [
      flow(),
      alias(Object.assign({}, aliases, opts.alias))
    ].concat(opts.plugins || []),
    output: {
      file: opts.dest,
      format: opts.format,
      banner: opts.banner,
      name: opts.moduleName || 'Vue'
    },
    onwarn: (msg, warn) => {
      if (!/Circular/.test(msg)) {
        warn(msg)
      }
    }
  }

  // built-in vars
  const vars = {
    __WEEX__: !!opts.weex,
    __WEEX_VERSION__: weexVersion,
    __VERSION__: version
  }
  // feature flags
  Object.keys(featureFlags).forEach(key => {
    vars[`process.env.${key}`] = featureFlags[key]
  })
  // build-specific env
  if (opts.env) {
    vars['process.env.NODE_ENV'] = JSON.stringify(opts.env)
  }
  config.plugins.push(replace(vars))

  if (opts.transpile !== false) {
    config.plugins.push(buble())
  }

  Object.defineProperty(config, '_name', {
    enumerable: false,
    value: name
  })

  return config
}
```

genConfig 通过 key 拿到 builds 中每个 key 对应的配置对象，然后根据这个对象重新定义一个 config 对象，这个 config 对象的结构才是 rollup 配置真正需要的结构。

看了 builds 对象和 genConfig 方法，我们就知道了 getAllBuilds 的目的，是通过映射把 builds 配置对象转化成 rollup 所需要的配置数据。

到这里，我们就清楚是如何构建出不同版本的 vue 代码了。

## 总结

学习源码时，不建议按照源码的顺序一行一行的阅读。首先要抓住主干，先梳理清楚主要的代码逻辑，再去仔细阅读具体的每行代码。另外按照源码顺序阅读可能很枯燥，很难坚持下来，可以先选择自己感兴趣的部分进行学习，最后再串联起来。