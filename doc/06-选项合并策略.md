# Vue 丰富的选项合并策略

## 前言

选项合并会在 `Vue` 实例化、`Vue.mixin`、`extends`、`mixin` 等场景使用，目的实现功能的扩展、复用。

## 选项合并使用场景

`new Vue` 执行 `_init` 方法进行选项合并

```js
Vue.prototype._init = function (options) {
  // ...
  if (options && options._isComponent) { // 子组件选项合并
    initInternalComponent(vm, options)
  } else {
    // 根组件选项合并，将合并后的选项赋值给实例的 $options 属性
    vm.$options = mergeOptions(
      resolveConstructorOptions(vm.constructor), // 返回 Vue 构造函数自身的配置项
      options || {},
      vm
    )
  }

  // ...
}
```

`resolveConstructorOptions` 选项合并

```js
function resolveConstructorOptions (Ctor: Class<Component>) {
  let options = Ctor.options
  if (Ctor.super) { // super 属性在 Vue.extend 会赋值
    // ....
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
    }
  }
  return options
}
```

`Vue.extend` 注册组件，选项合并

```js
Vue.extend = function (extendOptions: Object): Function {
    // ...
   
    // 子类和父类构造器的配置选项进行合并
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    // ...
}
```

`Vue.mixin` 选项合并


```js
Vue.mixin = function (mixin: Object) {
  this.options = mergeOptions(this.options, mixin)
  return this
}
```

## 选项校验

`mergeOptions` 在选项合并之前，会进行组件名称的检验、规范化 `props`, `inject` 和 `directives`

```js
function mergeOptions (parent,child,vm) {
    // 组件名称的检验
    {
      checkComponents(child);
    }
    if (typeof child === 'function') {
      child = child.options;
    }
    // props,inject,directives的校验和规范化
    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);
    // 针对extends, mixins 扩展的子类构造器，递归调用进行选项合并
    if (!child._base) {
      // extends
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      // mixins
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }
    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField (key) {
      // 拿到各个选择指定的选项配置，如果没有则用默认的配置
      var strat = strats[key] || defaultStrat;
      // 执行各自的合并策略
      options[key] = strat(parent[key], child[key], vm, key);
    }
    // console.log(options)
    return options
  }
```

### components 规范检验

 组件名称 `components` 由于写法比较随意，所以组件命名需要遵守很多规范，比如组件名首字符必须是字母，组件名称由字母、数字、`.`、`_`等组成，不能包含非法字符，不能用原生组件名 `component`, `slot`，不能用 `html` 保留的标签(如：h1, svg )。这些都会在 `validateComponentName` 函数做校验。

```js
// components规范检查函数
function checkComponents (options) {
  // 遍历components对象，对每个属性值校验。
  for (var key in options.components) {
    validateComponentName(key);
  }
}
function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    // 正则判断检测是否为非法的标签，例如数字开头
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  // 不能使用Vue自身自定义的组件名，如slot, component,不能使用html的保留标签，如 h1, svg 等
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}
```

### props 规范检验

`props` 选项的书写形式有两种，分别是

- 数组形式 `{ props: ['a', 'b', 'c'] }`
- 带校验规则的对象形式 `{ props: { a: { type: 'String', default: 'prop校验' } }}` 从源码上看，两种形式最终都会转换成对象的形式。

```js
// props规范校验
  function normalizeProps (options, vm) {
    var props = options.props;
    if (!props) { return }
    var res = {};
    var i, val, name;
    // props选项数据有两种形式，一种是['a', 'b', 'c'],一种是{ a: { type: 'String', default: 'hahah' }}
    // 数组
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          // 默认将数组形式的props转换为对象形式。
          res[name] = { type: null }; 
        } else {
          // 规则：保证是字符串
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val)
          ? val
          : { type: val };
      }
    } else {
      // 非数组，非对象则判定props选项传递非法
      warn(
        "Invalid value for option \"props\": expected an Array or an Object, " +
        "but got " + (toRawType(props)) + ".",
        vm
      );
    }
    options.props = res;
  }
```

### inject 的规范校验

`inject` 的用法和 `props` 的用法一样，有数组和对象两种方式

基本的使用如下：

```js
// 父组件
var Provider = {
  provide: {
    foo: 'bar'
  },
  // ...
}
// 后代组件
var Child = {
  // 数组写法
  inject: ['foo'],
  // 对象写法
  inject: {
    foo: {
      from: 'foo',
      default: 'bardefault'
    }
  }
}
```

`inject` 源码实现和 `props` 的校验规则一致，最终 `inject` 都会转换为对象的形式存在。

```js
// inject的规范化
function normalizeInject (options, vm) {
    var inject = options.inject;
    if (!inject) { return }
    var normalized = options.inject = {};
    //数组的形式
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        // from: 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      // 对象的处理
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val)
          ? extend({ from: key }, val)
          : { from: val };
      }
    } else {
      // 非法规则
      warn(
        "Invalid value for option \"inject\": expected an Array or an Object, " +
        "but got " + (toRawType(inject)) + ".",
        vm
      );
    }
  }
```

### directives 的规范校验

`Vue` 自定义指令提供了五个钩子函数 `bind, inserted, update, componentUpdated, unbind`, 除此之外，自定义指令还提供了函数的写法

```js
{
  directives: {
    'color-swatch': function(el, binding) {
        el.style.backgroundColor = binding.value
    }
  }
}
```

`vue` 源码实现，会规范化指令函数写法，将函数赋予 `bind,update` 钩子

```js
function normalizeDirectives (options: Object) {
  const dirs = options.directives
  if (dirs) {
    for (const key in dirs) {
      const def = dirs[key]
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def }
      }
    }
  }
}
```

## Vue 扩展复用

校验规范后，会针对 `extends` 和 `mixins` 选项进行递归处理

```js
if (!child._base) {
  // extends
  if (child.extends) {
    parent = mergeOptions(parent, child.extends, vm);
  }
  // mixins
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
}
```

## 选项合并策略

遍历 `parent` 和 `child` 调用 `mergeField` 方法，匹配定义的合并策略 `strats` ，不匹配则使用默认合并策略 `defaultStrat`, `vuex`、`vue-router`、`$axios` 等插件使用的是默认选项合并策略

```js
for (key in parent) {
  mergeField(key)
}
for (key in child) {
  if (!hasOwn(parent, key)) {
    mergeField(key)
  }
}
function mergeField (key) {
  // 拿到各个选择指定的选项配置，如果没有则用默认的配置
  // strats下每个key对应的便是每个特殊选项的合并策略
  const strat = strats[key] || defaultStrat
  // 执行各自的合并策略
  options[key] = strat(parent[key], child[key], vm, key)
}
```

## data 合并策略

`data` 在 `vue` 创建实例时传递的是一个对象，而在组件内部定义时只能传递一个函数

```js
// data的合并
strats.data = function (parentVal, childVal, vm) {
  // vm代表是否为Vue创建的实例，否则是子父类的关系
  if (!vm) {
    if (childVal && typeof childVal !== 'function') { // 必须保证子类的 data 类型是一个函数而不是一个对象
      warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.',vm);
      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }
  return mergeDataOrFn(parentVal, childVal, vm); // vue 实例时需要传递vm作为函数的第三个参数
};
```

`data` 策略最终调用的 `mergeDataOrFn` 方法，区别在于当前 `vm` 是否是实例，或者是单纯的子父类的关系。如果是子父类的关系，需要对 `data` 选项进行规范校验，保证它的类型是一个函数而不是对象。

```js
function mergeDataOrFn ( parentVal, childVal, vm ) {
  // 子父类
  if (!vm) {
    if (!childVal) { // 子类不存在data选项，则合并结果为父类data选项
      return parentVal
    }
    if (!parentVal) { // 父类不存在data选项，则合并结果为子类data选项
      return childVal
    }
    return function mergedDataFn () { // data选项在父类和子类同时存在的情况下返回的是一个函数
      // 子类实例和父类实例，分别将子类和父类实例中 data 函数执行后返回的对象传递给mergeData函数做数据合并
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
  // Vue实例
    // vue构造函数实例对象
    return function mergedInstanceDataFn () {
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        // 当实例中传递data选项时，将实例的data对象和Vm构造函数上的data属性选项合并
        return mergeData(instanceData, defaultData)
      } else {
        // 当实例中不传递data时，默认返回Vm构造函数上的data属性选项
        return defaultData
      }
    }
  }
}
```

从源码的实现看，`data` 的合并不是简单的将两个数据对象进行合并，而是直接返回一个 `mergedDataFn` 或者`mergedInstanceDataFn` 函数，而真正合并的时机是在后续初始化数据响应式系统的环节进行的，初始化数据响应式系统的第一步就是拿到合并后的数据，也就是执行 `mergeData` 逻辑。

```js
function mergeData (to: Object, from: ?Object): Object {
  if (!from) return to
  let key, toVal, fromVal

  // Reflect.ownKeys可以拿到Symbol属性
  const keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from)

  for (let i = 0; i < keys.length; i++) {
    key = keys[i]
    // in case the object is already observed...
    if (key === '__ob__') continue
    toVal = to[key]
    fromVal = from[key]
    if (!hasOwn(to, key)) {
      // 子的数据父没有，则将新增的数据加入响应式系统中。
      set(to, key, fromVal)
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
        // 处理深层对象，当合并的数据为多层嵌套对象时，需要递归调用mergeData进行比较合并
      mergeData(toVal, fromVal)
    }
  }
  return to
}
```

`mergeData` 方法的两个参数是父 `data` 选项和子 `data` 选项的结果，也就是两个 `data` 对象，从源码上看数据合并的原则是，将父类的数据整合到子类的数据选项中，如若父类数据和子类数据冲突时，保留子类数据。如果对象有深层嵌套，则需要递归调用 `mergeData` 进行数据合并。

为什么 `Vue` 组件的`data` 是一个函数，而不是一个对象呢？可以通过函数作用域来解释：组件设计的目的是为了复用，每次通过函数创建相当于在一个独立的内存空间中生成一个 `data` 的副本，这样每个组件之间的数据不会互相影响。

## 生命周期钩子函数合并策略

`Vue` 的生命周期钩子函数多达12个，我们在使用 `mixin`，`extends` 选项会混入生命周期钩子函数，那么子父组件的生命周期钩子函数是遵循什么样的规则合并

```js
const LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
]

LIFECYCLE_HOOKS.forEach(hook => {
  strats[hook] = mergeHook // 对生命周期钩子选项的合并都执行mergeHook策略
})
```

`mergeHook` 是生命周期钩子合并的策略，简单的对代码进行总结，钩子函数的合并原则是：

- 如果子类和父类都拥有相同钩子选项，则将子类选项和父类选项合并。
- 如果父类不存在钩子选项，子类存在时，则以数组形式返回子类钩子选项。
- 当子类不存在钩子选项时，则以父类选项返回。
- 子父合并时，是将子类选项放在数组的末尾，这样在执行钩子时，永远是父类选项优先于子类选项执行，子类的执行结果会覆盖父类。

```js
// 生命周期钩子选项合并策略
function mergeHook (
    parentVal,
    childVal
  ) {
    // 1.如果子类和父类都拥有钩子选项，则将子类选项和父类选项合并, 
    // 2.如果父类不存在钩子选项，子类存在时，则以数组形式返回子类钩子选项，
    // 3.当子类不存在钩子选项时，则以父类选项返回。
    var res = childVal ? 
                parentVal ? 
                  parentVal.concat(childVal) 
                  : Array.isArray(childVal) ? 
                  childVal : [childVal] 
              : parentVal; 
    return res
      ? dedupeHooks(res)
      : res
  }
// 去重，防止多个组件实例钩子选项相互影响
  function dedupeHooks (hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
      if (res.indexOf(hooks[i]) === -1) {
        res.push(hooks[i]);
      }
    }
    return res
  }
```

## components, filters, directives 资源合并策略

`Vue` 默认会带几个选项，分别是 `components` 组件, `directives` 指令, `filters` 过滤器, `_base`, 无论是根实例，还是父子实例，都需要和系统自带的资源选项进行合并。它的定义如下：

```js
// 资源选项
var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];
// 定义资源合并的策略
ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets; // 定义默认策略
});
```

资源选项的合并，首先会创建一个原型指向父类资源选项的空对象，再将子类选项赋值给空对象。

```js
// 资源选项自定义合并策略
function mergeAssets (parentVal,childVal,vm,key) {
  var res = Object.create(parentVal || null); // 创建一个空对象，其原型指向父类的资源选项。
  if (childVal) {
    assertObjectType(key, childVal, vm); // components,filters,directives选项必须为对象
    return extend(res, childVal) // 子类选项赋值给空对象
  } else {
    return res
  }
}
```

结合下面的例子，看具体合并后的结果：

```js
var vm = new Vue({
  components: {
    componentA: {}
  },
  directives: {
    'v-boom': {}
  }
})
console.log(vm.$options.components, vm.$options.directives)
// 根实例的选项和资源默认选项合并后的结果
{
  components: {
    componentA: {},
    __proto__: {
      KeepAlive: {}
      Transition: {}
      TransitionGroup: {}
    } 
  },
  directives: {
    'v-boom': {},
    __proto__: {
      'v-show': {},
      'v-model': {}
    }
  }
}
```

## watch 选项合并策略

当需要在数据变化时执行异步或者开销较大的操作时，`watch` 往往是高效的。对于 `watch` 选项的合并处理，它类似于生命周期钩子，只要父选项有相同的观测字段，则和子的选项合并为数组，在监测字段改变时同时执行父类选项的监听代码。处理方式和生命钩子选项的区别在于，生命周期钩子选项必须是函数，而 `watch` 选项最终在合并的数组中可以是包含选项的对象，也可以是对应的回调函数，或者方法名。

```js
strats.watch = function (parentVal,childVal,vm,key) {
    //火狐浏览器在Object的原型上拥有watch方法，这里对这一现象做了兼容
    // var nativeWatch = ({}).watch;
    if (parentVal === nativeWatch) { parentVal = undefined; }
    if (childVal === nativeWatch) { childVal = undefined; }
    // 没有子，则默认用父选项
    if (!childVal) { return Object.create(parentVal || null) }
    {
      // 保证watch选项是一个对象
      assertObjectType(key, childVal, vm);
    }
    // 没有父则直接用子选项
    if (!parentVal) { return childVal }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      // 父的选项先转换成数组
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent
        ? parent.concat(child)
        : Array.isArray(child) ? child : [child];
    }
    return ret
  };
```

  下面结合具体的例子看合并结果：

  ```js
var Parent = Vue.extend({
  watch: {
    'test': function() {
      console.log('parent change')
    }
  }
})
var Child = Parent.extend({
  watch: {
    'test': {
      handler: function() {
        console.log('child change')
      }
    }
  },
  data() {
    return {
      test: 1
    }
  }
})
var vm = new Child().$mount('#app');
vm.test = 2;
// 输出结果
parent change
child change
  ```

  对于 `watch` 选项的合并，最终和父类选项合并成数组，并且数组的选项成员，可以是回调函数，选项对象，或者函数名。

## props，methods，inject，computed 合并策略

源码的设计将 `props, methods, inject, computed` 归结为一类，他们的配置策略一致，简单概括就是，如果父类不存在选项，则返回子类选项，子类父类都存在时，用子类选项去覆盖父类选项。

```js
// 其他选项合并策略
strats.props =
strats.methods =
strats.inject =
strats.computed = function (parentVal,childVal,vm,key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal } // 父类不存在该选项，则返回子类的选项
  var ret = Object.create(null);
  extend(ret, parentVal); // 
  if (childVal) { 
    // 子类选项会覆盖父类选项的值
    extend(ret, childVal); } 
  return ret
};
```

## provide 合并策略

`provide` 合并策略和 `data` 合并策略相同

```js
strats.provide = mergeDataOrFn
```

## defaultStrat 默认合并策略

当 `vue` 没有定义合并策略时，则使用默认合并策略，比如 `vuex`, `vue-router` 使用 `defaultStrat` 合并

```js
const defaultStrat = function (parentVal: any, childVal: any): any {
  return childVal === undefined
    ? parentVal
    : childVal
}
```